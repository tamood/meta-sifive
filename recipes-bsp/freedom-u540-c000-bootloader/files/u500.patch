diff --git a/Makefile b/Makefile
index b7204ed..e638588 100644
--- a/Makefile
+++ b/Makefile
@@ -3,12 +3,12 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 # See the file LICENSE for further information
 
-CROSSCOMPILE?=riscv64-unknown-elf-
-CC=${CROSSCOMPILE}gcc
-LD=${CROSSCOMPILE}ld
-OBJCOPY=${CROSSCOMPILE}objcopy
-OBJDUMP=${CROSSCOMPILE}objdump
-CFLAGS=-I. -O2 -ggdb -march=rv64imafdc -mabi=lp64d -Wall -mcmodel=medany -mexplicit-relocs
+#CROSSCOMPILE?=riscv64-unknown-elf-
+#CC=${CROSSCOMPILE}gcc
+#LD=${CROSSCOMPILE}ld
+#OBJCOPY=${CROSSCOMPILE}objcopy
+#OBJDUMP=${CROSSCOMPILE}objdump
+CFLAGS=-I. -O1 -ggdb -march=rv64imafdc -mabi=lp64d -Wall -mcmodel=medany -mexplicit-relocs -Wno-main -no-pie -fno-PIE -DSKIP_ECC_WIPEDOWN -DSKIP_OTP_MAC
 CCASFLAGS=-I. -mcmodel=medany -mexplicit-relocs
 LDFLAGS=-nostdlib -nostartfiles
 
@@ -52,7 +52,7 @@ asm: zsbl.asm fsbl.asm
 
 lib/version.c: .git/HEAD .git/index
 	echo "const char *gitid = \"$(shell git describe --always --dirty)\";" > lib/version.c
-	echo "const char *gitdate = \"$(shell git log -n 1 --date=short --format=format:"%ad.%h" HEAD)\";" >> lib/version.c
+	echo "const char *gitdate = \"$(shell git log -n 1 --date=short --format=format:"%ad.%h" --no-show-signatures HEAD)\";" >> lib/version.c
 	echo "const char *gitversion = \"$(shell git rev-parse HEAD)\";" >> lib/version.c
 #	echo "const char *gitstatus = \"$(shell git status -s )\";" >> lib/version.c
 
@@ -73,7 +73,7 @@ fsbl/dtb.o: fsbl/ux00_fsbl.dtb
 zsbl/start.o: zsbl/ux00_zsbl.dtb
 
 %.bin: %.elf
-	$(OBJCOPY) -O binary $^ $@
+	$(OBJCOPY) -S -R .comment -R .note.gnu.build-id -O binary $^ $@
 
 %.asm: %.elf
 	$(OBJDUMP) -S $^ > $@
diff --git a/fsbl/main.c b/fsbl/main.c
index ed1321b..fcb84a3 100644
--- a/fsbl/main.c
+++ b/fsbl/main.c
@@ -9,22 +9,9 @@
 #include <string.h>
 #include <stdatomic.h>
 #include "fdt/fdt.h"
-#include <ememoryotp/ememoryotp.h>
 #include <uart/uart.h>
 #include <stdio.h>
 
-#include "regconfig-ctl.h"
-#include "regconfig-phy.h"
-#include "fsbl/ux00ddr.h"
-
-#define DENALI_PHY_DATA ddr_phy_settings
-#define DENALI_CTL_DATA ddr_ctl_settings
-#include "ddrregs.h"
-
-#define DDR_SIZE  (8UL * 1024UL * 1024UL * 1024UL)
-#define DDRCTLPLL_F 55
-#define DDRCTLPLL_Q 2
-
 #include <sifive/platform.h>
 #include <sifive/barrier.h>
 #include <stdatomic.h>
@@ -35,20 +22,11 @@
 #include <ux00boot/ux00boot.h>
 #include <gpt/gpt.h>
 
-#define NUM_CORES 5
+#define NUM_CORES 2
 
 #ifndef PAYLOAD_DEST
   #define PAYLOAD_DEST MEMORY_MEM_ADDR
-#endif
-
-#ifndef SPI_MEM_ADDR
-  #ifndef SPI_NUM
-    #define SPI_NUM 0
-  #endif
-
-  #define _CONCAT3(A, B, C) A ## B ## C
-  #define _SPI_MEM_ADDR(SPI_NUM) _CONCAT3(SPI, SPI_NUM, _MEM_ADDR)
-  #define SPI_MEM_ADDR _SPI_MEM_ADDR(SPI_NUM)
+  #define DDR_SIZE  MEMORY_MEM_SIZE
 #endif
 
 Barrier barrier = { {0, 0}, {0, 0}, 0}; // bss initialization is done by main core while others do wfi
@@ -100,7 +78,7 @@ void update_peripheral_clock_dividers(unsigned int peripheral_input_khz)
     _REG32(i2c_devices[i], I2C_PRESCALER_HI) = (prescaler >> 8) & 0xff;
   }
 
-  unsigned int spi_target_khz = 50000;
+  unsigned int spi_target_khz = 10000;
   unsigned int spi_div = spi_min_clk_divisor(peripheral_input_khz, spi_target_khz);
   for (size_t i = 0; i < sizeof(spi_devices) / sizeof(spi_devices[0]); i++) {
     spi_devices[i]->sckdiv = spi_div;
@@ -113,7 +91,7 @@ void update_peripheral_clock_dividers(unsigned int peripheral_input_khz)
   }
 }
 
-long nsec_per_cyc = 300; // 33.333MHz
+long nsec_per_cyc = 20; // 50MHz
 void nsleep(long nsec) {
   long step = nsec_per_cyc*2; // 2 instructions per loop iteration
   while (nsec > 0) nsec -= step;
@@ -123,168 +101,15 @@ int puts(const char * str){
 	uart_puts((void *) UART0_CTRL_ADDR, str);
 	return 1;
 }
-
+#define peripheral_input_khz 50000
 //HART 0 runs main
 
 int main(int id, unsigned long dtb)
 {
-  // PRCI init
-
-  // Initialize UART divider for 33MHz core clock in case if trap is taken prior
-  // to core clock bump.
-  unsigned long long uart_target_hz = 115200ULL;
-  const uint32_t initial_core_clk_khz = 33000;
-  unsigned long peripheral_input_khz;
-  if (UX00PRCI_REG(UX00PRCI_CLKMUXSTATUSREG) & CLKMUX_STATUS_TLCLKSEL){
-    peripheral_input_khz = initial_core_clk_khz;
-  } else {
-    peripheral_input_khz = initial_core_clk_khz / 2;
-  }
-  UART0_REG(UART_REG_DIV) = uart_min_clk_divisor(peripheral_input_khz * 1000ULL, uart_target_hz);
-
-  // Check Reset Values (lock don't care)
-  uint32_t pll_default =
-    (PLL_R(PLL_R_default)) |
-    (PLL_F(PLL_F_default)) |
-    (PLL_Q(PLL_Q_default)) |
-    (PLL_RANGE(PLL_RANGE_default)) |
-    (PLL_BYPASS(PLL_BYPASS_default)) |
-    (PLL_FSE(PLL_FSE_default));
-  uint32_t lockmask = ~PLL_LOCK(1);
-  uint32_t pllout_default =
-    (PLLOUT_DIV(PLLOUT_DIV_default)) |
-    (PLLOUT_DIV_BY_1(PLLOUT_DIV_BY_1_default)) |
-    (PLLOUT_CLK_EN(PLLOUT_CLK_EN_default));
-
-  if ((UX00PRCI_REG(UX00PRCI_COREPLLCFG)     ^ pll_default) & lockmask) return (__LINE__);
-  if ((UX00PRCI_REG(UX00PRCI_COREPLLOUT)     ^ pllout_default))         return (__LINE__);
-  if ((UX00PRCI_REG(UX00PRCI_DDRPLLCFG)      ^ pll_default) & lockmask) return (__LINE__);
-  if ((UX00PRCI_REG(UX00PRCI_DDRPLLOUT)      ^ pllout_default))         return (__LINE__);
-  if (((UX00PRCI_REG(UX00PRCI_GEMGXLPLLCFG)) ^ pll_default) & lockmask) return (__LINE__);
-  if (((UX00PRCI_REG(UX00PRCI_GEMGXLPLLOUT)) ^ pllout_default))         return (__LINE__);
-
-  //CORE pll init
-  // If tlclksel is set for 2:1 operation,
-  // Set corepll 33Mhz -> 1GHz
-  // Otherwise, set corepll 33MHz -> 500MHz.
-  
-  if (UX00PRCI_REG(UX00PRCI_CLKMUXSTATUSREG) & CLKMUX_STATUS_TLCLKSEL){
-    nsec_per_cyc = 2;
-    peripheral_input_khz = 500000; // peripheral_clk = tlclk
-    update_peripheral_clock_dividers(peripheral_input_khz);
-    ux00prci_select_corepll_500MHz(&UX00PRCI_REG(UX00PRCI_CORECLKSELREG),
-                                   &UX00PRCI_REG(UX00PRCI_COREPLLCFG),
-                                   &UX00PRCI_REG(UX00PRCI_COREPLLOUT));
-  } else {
-    nsec_per_cyc = 1;
-    peripheral_input_khz = (1000000 / 2); // peripheral_clk = tlclk
-    update_peripheral_clock_dividers(peripheral_input_khz);
-    
-    ux00prci_select_corepll_1GHz(&UX00PRCI_REG(UX00PRCI_CORECLKSELREG),
-                                 &UX00PRCI_REG(UX00PRCI_COREPLLCFG),
-                                 &UX00PRCI_REG(UX00PRCI_COREPLLOUT));
-  }
-  
-  //
-  //DDR init
-  //
-
-  uint32_t ddrctlmhz =
-    (PLL_R(0)) |
-    (PLL_F(DDRCTLPLL_F)) |
-    (PLL_Q(DDRCTLPLL_Q)) |
-    (PLL_RANGE(0x4)) |
-    (PLL_BYPASS(0)) |
-    (PLL_FSE(1));
-  UX00PRCI_REG(UX00PRCI_DDRPLLCFG) = ddrctlmhz;
-
-  // Wait for lock
-  while ((UX00PRCI_REG(UX00PRCI_DDRPLLCFG) & PLL_LOCK(1)) == 0) ;
-
-  uint32_t ddrctl_out =
-    (PLLOUT_DIV(PLLOUT_DIV_default)) |
-    (PLLOUT_DIV_BY_1(PLLOUT_DIV_BY_1_default)) |
-    (PLLOUT_CLK_EN(1));
-  (UX00PRCI_REG(UX00PRCI_DDRPLLOUT)) = ddrctl_out;
-
-  //Release DDR reset.
-  UX00PRCI_REG(UX00PRCI_DEVICESRESETREG) |= DEVICESRESET_DDR_CTRL_RST_N(1);
-  asm volatile ("fence"); // HACK to get the '1 full controller clock cycle'.
-  UX00PRCI_REG(UX00PRCI_DEVICESRESETREG) |= DEVICESRESET_DDR_AXI_RST_N(1) | DEVICESRESET_DDR_AHB_RST_N(1) | DEVICESRESET_DDR_PHY_RST_N(1);
-  asm volatile ("fence"); // HACK to get the '1 full controller clock cycle'.
-  // These take like 16 cycles to actually propogate. We can't go sending stuff before they
-  // come out of reset. So wait. (TODO: Add a register to read the current reset states, or DDR Control device?)
-  for (int i = 0; i < 256; i++){
-    asm volatile ("nop");
-  }
-  
-  ux00ddr_writeregmap(UX00DDR_CTRL_ADDR,ddr_ctl_settings,ddr_phy_settings);
-  ux00ddr_disableaxireadinterleave(UX00DDR_CTRL_ADDR);
-
-  ux00ddr_disableoptimalrmodw(UX00DDR_CTRL_ADDR);  
-
-  ux00ddr_enablewriteleveling(UX00DDR_CTRL_ADDR);
-  ux00ddr_enablereadleveling(UX00DDR_CTRL_ADDR);
-  ux00ddr_enablereadlevelinggate(UX00DDR_CTRL_ADDR);
-  if(ux00ddr_getdramclass(UX00DDR_CTRL_ADDR) == DRAM_CLASS_DDR4)
-    ux00ddr_enablevreftraining(UX00DDR_CTRL_ADDR);
-  //mask off interrupts for leveling completion
-  ux00ddr_mask_leveling_completed_interrupt(UX00DDR_CTRL_ADDR);
-
-  ux00ddr_mask_mc_init_complete_interrupt(UX00DDR_CTRL_ADDR);
-  ux00ddr_mask_outofrange_interrupts(UX00DDR_CTRL_ADDR);
-  ux00ddr_setuprangeprotection(UX00DDR_CTRL_ADDR,DDR_SIZE);
-  ux00ddr_mask_port_command_error_interrupt(UX00DDR_CTRL_ADDR);
+  update_peripheral_clock_dividers(peripheral_input_khz);
 
   const uint64_t ddr_size = DDR_SIZE;
   const uint64_t ddr_end = PAYLOAD_DEST + ddr_size;
-  ux00ddr_start(UX00DDR_CTRL_ADDR, PHYSICAL_FILTER_CTRL_ADDR, ddr_end);
-
-  ux00ddr_phy_fixup(UX00DDR_CTRL_ADDR); 
-  
-  //
-  //GEMGXL init
-  //
-
-  uint32_t gemgxl125mhz =
-    (PLL_R(0)) |
-    (PLL_F(59)) |  /*4000Mhz VCO*/
-    (PLL_Q(5)) |   /* /32 */
-    (PLL_RANGE(0x4)) |
-    (PLL_BYPASS(0)) |
-    (PLL_FSE(1));
-  UX00PRCI_REG(UX00PRCI_GEMGXLPLLCFG) = gemgxl125mhz;
-
-  // Wait for lock
-  while ((UX00PRCI_REG(UX00PRCI_GEMGXLPLLCFG) & PLL_LOCK(1)) == 0) ;
-
-  uint32_t gemgxlctl_out =
-    (PLLOUT_DIV(PLLOUT_DIV_default)) |
-    (PLLOUT_DIV_BY_1(PLLOUT_DIV_BY_1_default)) |
-    (PLLOUT_CLK_EN(1));
-  UX00PRCI_REG(UX00PRCI_GEMGXLPLLOUT) = gemgxlctl_out;
-
-  //Release GEMGXL reset (set bit DEVICESRESET_GEMGXL to 1)
-  UX00PRCI_REG(UX00PRCI_DEVICESRESETREG) |= DEVICESRESET_GEMGXL_RST_N(1);
-
-//#ifdef VSC8541_PHY
-#define PHY_NRESET 0x1000
-
-  // VSC8541 PHY reset sequence; leave pull-down active for 2ms
-  nsleep(2000000);
-  // Set GPIO 12 (PHY NRESET) to OE=1 and OVAL=1
-  atomic_fetch_or(&GPIO_REG(GPIO_OUTPUT_VAL), PHY_NRESET);
-  atomic_fetch_or(&GPIO_REG(GPIO_OUTPUT_EN),  PHY_NRESET);
-  nsleep(100);
-  // Reset PHY again to enter unmanaged mode
-  atomic_fetch_and(&GPIO_REG(GPIO_OUTPUT_VAL), ~PHY_NRESET);
-  nsleep(100);
-  atomic_fetch_or(&GPIO_REG(GPIO_OUTPUT_VAL), PHY_NRESET);
-  nsleep(15000000);
-//#endif
-
-  // Procmon => core clock
-  UX00PRCI_REG(UX00PRCI_PROCMONCFG) = 0x1 << 24;
 
   // Copy the DTB and reduce the reported memory to match DDR
   dtb_target = ddr_end - 0x200000; // - 2MB
@@ -315,14 +140,8 @@ int main(int id, unsigned long dtb)
   puts(date);
   puts("-");
   puts(gitid);
-  // If chiplink is connected and has a DTB, use that DTB instead of what we have
-  // compiled-in. This will be replaced with a real bootloader with overlays in
-  // the future
-  uint32_t *chiplink_dtb = (uint32_t*)0x2ff0000000UL;
-  if (*chiplink_dtb == 0xedfe0dd0){
-	dtb = (uintptr_t)chiplink_dtb;
-	puts("\r\nUsing Chiplink DTB");
-  } else if (own_dtb == 0xedfe0dd0){
+  // Copy own dtb
+  if (own_dtb == 0xedfe0dd0){
 	dtb = (uintptr_t)&own_dtb;
 	puts("\r\nUsing FSBL DTB");
   }
@@ -381,9 +200,9 @@ int main(int id, unsigned long dtb)
     mac[3] |= (serial >> 16) & 0xff;
   }
   fdt_set_prop(dtb_target, "local-mac-address", &mac[0]);
-#endif
   uart_puts(uart, "\r\n");
-#endif
+#endif /*SKIP_OTP_MAC*/
+#endif /*SKIP_DTB_DDR_RANGE*/
 
   puts("Loading boot payload");
   ux00boot_load_gpt_partition((void*) PAYLOAD_DEST, &gpt_guid_sifive_bare_metal, peripheral_input_khz);
@@ -417,7 +236,7 @@ int slave_main(int id, unsigned long dtb)
 #endif
   // These next two guys must get inlined and not spill a0+a1 or it is broken!
   Barrier_Wait(&barrier, NUM_CORES);
-  ccache_enable_ways(CCACHE_CTRL_ADDR,14);
+  asm volatile ("ebreak");
   asm volatile ("unimp" : : "r"(a0), "r"(a1));
 
   return 0;
diff --git a/lib/strlen.c b/lib/strlen.c
index 565955f..3d6addf 100644
--- a/lib/strlen.c
+++ b/lib/strlen.c
@@ -17,6 +17,14 @@
 #include <string.h>
 #include <stdint.h>
 
+static __inline unsigned long detect_null(unsigned long w)
+{
+  unsigned long mask = 0x7f7f7f7f;
+  if (sizeof (long) == 8)
+    mask = ((mask << 16) << 16) | mask;
+  return ~(((w & mask) + mask) | w | mask);
+}
+
 size_t strlen(const char *str)
 {
   const char *start = str;
@@ -35,7 +43,7 @@ size_t strlen(const char *str)
     } while ((uintptr_t)str & (sizeof (long) - 1));
 
   unsigned long *ls = (unsigned long *)str;
-  while (!__libc_detect_null (*ls++))
+  while (!detect_null (*ls++))
     ;
   asm volatile ("" : "+r"(ls)); /* prevent "optimization" */
 
diff --git a/memory.lds b/memory.lds
index ec9a43f..428a6b3 100644
--- a/memory.lds
+++ b/memory.lds
@@ -9,7 +9,7 @@ MEMORY
   modeselect_mem (rx) : ORIGIN = 0x1000, LENGTH = 0x1000
   test_ctrl (rw) : ORIGIN = 0x4000, LENGTH = 0x1000
   maskrom_mem (rx) : ORIGIN = 0x10000, LENGTH = 0x8000
-  dtim_mem (rwx) : ORIGIN = 0x1000000, LENGTH = 0x2000
+  dtim_mem (rwx) : ORIGIN = 0x1000000, LENGTH = 0x8000
   buserror0_ctrl (rw) : ORIGIN = 0x1700000, LENGTH = 0x1000
   buserror1_ctrl (rw) : ORIGIN = 0x1701000, LENGTH = 0x1000
   buserror2_ctrl (rw) : ORIGIN = 0x1702000, LENGTH = 0x1000
diff --git a/sd/sd.c b/sd/sd.c
index c4e3992..6feef45 100644
--- a/sd/sd.c
+++ b/sd/sd.c
@@ -24,7 +24,7 @@
 // SD card initialization must happen at 100-400kHz
 #define SD_POWER_ON_FREQ_KHZ 400L
 // SD cards normally support reading/writing at 20MHz
-#define SD_POST_INIT_CLK_KHZ 20000L
+#define SD_POST_INIT_CLK_KHZ 10000L
 
 
 // Command frame starts by asserting low and then high for first two clock edges
diff --git a/sifive/platform.h b/sifive/platform.h
index dd5be1d..221bb33 100644
--- a/sifive/platform.h
+++ b/sifive/platform.h
@@ -30,9 +30,9 @@
  *****************************************************************************/
 
 // CPU info
-#define NUM_CORES 5
-#define MAX_HART_ID 4
-#define GLOBAL_INT_SIZE 59
+#define NUM_CORES 2
+#define MAX_HART_ID 1
+#define GLOBAL_INT_SIZE 111
 #define GLOBAL_INT_MAX_PRIORITY 7
 #define RTC_FREQUENCY_HZ _AC(1000000,UL)
 #define RTC_PERIOD_NS _AC(1000,UL)
@@ -81,7 +81,7 @@
 #define DMA_CTRL_ADDR _AC(0x3000000,UL)
 #define DMA_CTRL_SIZE _AC(0x100000,UL)
 #define DTIM_MEM_ADDR _AC(0x1000000,UL)
-#define DTIM_MEM_SIZE _AC(0x2000,UL)
+#define DTIM_MEM_SIZE _AC(0x8000,UL)
 #define EMEMORYOTP_CTRL_ADDR _AC(0x10070000,UL)
 #define EMEMORYOTP_CTRL_SIZE _AC(0x1000,UL)
 #define ERROR_MEM_ADDR _AC(0x18000000,UL)
@@ -111,7 +111,7 @@
 #define MASKROM_MEM_ADDR _AC(0x10000,UL)
 #define MASKROM_MEM_SIZE _AC(0x8000,UL)
 #define MEMORY_MEM_ADDR _AC(0x80000000,UL)
-#define MEMORY_MEM_SIZE _AC(0x80000000,UL)
+#define MEMORY_MEM_SIZE _AC(0x8000000,UL)
 #define MODESELECT_MEM_ADDR _AC(0x1000,UL)
 #define MODESELECT_MEM_SIZE _AC(0x1000,UL)
 #define MSI_CTRL_ADDR _AC(0x2020000,UL)
@@ -178,18 +178,18 @@
 
 // Interrupt numbers
 #define CCACHE_INT_BASE 1
-#define UART0_INT_BASE 5
-#define UART1_INT_BASE 6
-#define SPI2_INT_BASE 7
-#define GPIO_INT_BASE 8
+#define UART0_INT_BASE 1
+#define UART1_INT_BASE 2
+#define SPI2_INT_BASE 3
+#define GPIO_INT_BASE 7
 #define DMA_INT_BASE 24
 #define UX00DDR_INT_BASE 32
 #define MSI_INT_BASE 33
-#define PWM0_INT_BASE 43
-#define PWM1_INT_BASE 47
-#define I2C_INT_BASE 51
-#define SPI0_INT_BASE 52
-#define SPI1_INT_BASE 53
+#define PWM0_INT_BASE 98
+#define PWM1_INT_BASE 102
+#define I2C_INT_BASE 110
+#define SPI0_INT_BASE 5
+#define SPI1_INT_BASE 6
 #define MAC_INT_BASE 54
 #define BUSERROR0_INT_BASE 55
 #define BUSERROR1_INT_BASE 56
@@ -340,7 +340,7 @@
 #define ALOE 
 #define SPI0_CS_WIDTH 1
 #define SPI0_SCKDIV_WIDTH 16
-#define SPI1_CS_WIDTH 4
+#define SPI1_CS_WIDTH 1
 #define SPI1_SCKDIV_WIDTH 16
 #define SPI2_CS_WIDTH 1
 #define SPI2_SCKDIV_WIDTH 16
diff --git a/sifive/smp.h b/sifive/smp.h
index 59cd32f..d101b8f 100644
--- a/sifive/smp.h
+++ b/sifive/smp.h
@@ -23,7 +23,7 @@
 #endif
 
 /* If your test cannot handle multiple-threads, use this: 
- *   smp_disable(reg1)
+ *   smp_disable(reg1, reg2)
  */
 #define smp_disable(reg1, reg2)			 \
   csrr reg1, mhartid				;\
diff --git a/ux00_fsbl.lds b/ux00_fsbl.lds
index 53c8427..c7f8aba 100644
--- a/ux00_fsbl.lds
+++ b/ux00_fsbl.lds
@@ -19,66 +19,66 @@ PHDRS
 
 SECTIONS
 {
-  PROVIDE(_ram = ORIGIN(ccache_sideband));
-  PROVIDE(_ram_end = _ram + LENGTH(ccache_sideband));
+  PROVIDE(_ram = ORIGIN(dtim_mem));
+  PROVIDE(_ram_end = _ram + LENGTH(dtim_mem));
 
   
 
-  .text ALIGN((ORIGIN(ccache_sideband) + 0x0), 8) : AT(ALIGN((ORIGIN(ccache_sideband) + 0x0), 8)) {
+  .text ALIGN((ORIGIN(dtim_mem) + 0x0), 64) : AT(ALIGN((ORIGIN(dtim_mem) + 0x0), 64)) {
     PROVIDE(_ftext = .);
     *(.text.init)
     *(.text.unlikely .text.unlikely.*)
     *(.text .text.* .gnu.linkonce.t.*)
     PROVIDE(_etext = .);
     . += 0x40; /* to create a gap between .text and .data b/c ifetch can fetch ahead from .data */
-  } >ccache_sideband  :text
+  } >dtim_mem  :text
 
-  .eh_frame ALIGN((ADDR(.text) + SIZEOF(.text)), 8) : AT(ALIGN((LOADADDR(.text) + SIZEOF(.text)), 8)) {
+  .eh_frame ALIGN((ADDR(.text) + SIZEOF(.text)), 64) : AT(ALIGN((LOADADDR(.text) + SIZEOF(.text)), 64)) {
     *(.eh_frame)
-  } >ccache_sideband  :text
+  } >dtim_mem  :text
 
-  .rodata ALIGN((ADDR(.eh_frame) + SIZEOF(.eh_frame)), 8) : AT(ALIGN((LOADADDR(.eh_frame) + SIZEOF(.eh_frame)), 8)) ALIGN_WITH_INPUT {
+  .rodata ALIGN((ADDR(.eh_frame) + SIZEOF(.eh_frame)), 64) : AT(ALIGN((LOADADDR(.eh_frame) + SIZEOF(.eh_frame)), 64)) ALIGN_WITH_INPUT {
     *(.rodata .rodata.* .gnu.linkonce.r.*)
-  } >ccache_sideband  :rodata
+  } >dtim_mem  :rodata
 
-  .srodata ALIGN((ADDR(.rodata) + SIZEOF(.rodata)), 8) : AT(ALIGN((LOADADDR(.rodata) + SIZEOF(.rodata)), 8)) ALIGN_WITH_INPUT {
+  .srodata ALIGN((ADDR(.rodata) + SIZEOF(.rodata)), 64) : AT(ALIGN((LOADADDR(.rodata) + SIZEOF(.rodata)), 64)) ALIGN_WITH_INPUT {
     *(.srodata.cst16)
     *(.srodata.cst8)
     *(.srodata.cst4)
     *(.srodata.cst2)
     *(.srodata.*)
-  } >ccache_sideband  :rodata
+  } >dtim_mem  :rodata
 
-  .data ALIGN((ADDR(.srodata) + SIZEOF(.srodata)), 8) : AT(ALIGN((LOADADDR(.srodata) + SIZEOF(.srodata)), 8)) ALIGN_WITH_INPUT {
+  .data ALIGN((ORIGIN(dtim_mem) + 0x2700), 64) : AT(ALIGN((LOADADDR(.srodata) + SIZEOF(.srodata)), 64)) ALIGN_WITH_INPUT {
     *(.data .data.* .gnu.linkonce.d.*)
     *(.tohost) /* TODO: Support sections that aren't explicitly listed in this linker script */
-  } >ccache_sideband  :data
+  } >dtim_mem  :data
 
-  .sdata ALIGN((ADDR(.data) + SIZEOF(.data)), 8) : AT(ALIGN((LOADADDR(.data) + SIZEOF(.data)), 8)) ALIGN_WITH_INPUT {
+  .sdata ALIGN((ADDR(.data) + SIZEOF(.data)), 64) : AT(ALIGN((LOADADDR(.data) + SIZEOF(.data)), 64)) ALIGN_WITH_INPUT {
     *(.sdata .sdata.* .gnu.linkonce.s.*)
-  } >ccache_sideband  :data
+  } >dtim_mem  :data
 
   PROVIDE(_data = ADDR(.data));
   PROVIDE(_data_lma = LOADADDR(.data));
   PROVIDE(_edata = .);
 
-  .bss ALIGN((ADDR(.sdata) + SIZEOF(.sdata)), 8) : AT(ALIGN((LOADADDR(.sdata) + SIZEOF(.sdata)), 8)) ALIGN(8) {
+  .bss ALIGN((ADDR(.sdata) + SIZEOF(.sdata)), 64) : AT(ALIGN((ORIGIN(dtim_mem) + 0x2700), 64)) ALIGN(8) {
     PROVIDE(_fbss = .);
     PROVIDE(__global_pointer$ = . + 0x7C0);
     *(.sbss .sbss.* .gnu.linkonce.sb.*)
     *(.bss .bss.* .gnu.linkonce.b.*)
     . = ALIGN(8);
     PROVIDE(_ebss = .);
-  } >ccache_sideband  :bss
+  } >dtim_mem  :bss
 
   PROVIDE(_end = .);
 
   /*
-   * heap_stack_region_usable_end: (ORIGIN(ccache_sideband) + LENGTH(ccache_sideband))
+   * heap_stack_region_usable_end: (ORIGIN(dtim_mem) + LENGTH(dtim_mem))
    * heap_stack_min_size: 4096
    * heap_stack_max_size: 1048576
    */
-  PROVIDE(_sp = ALIGN(MIN((ORIGIN(ccache_sideband) + LENGTH(ccache_sideband)), _ebss + 1048576) - 7, 8));
+  PROVIDE(_sp = ALIGN(MIN((ORIGIN(dtim_mem) + LENGTH(dtim_mem)), _ebss + 1048576) - 7, 8));
   /*
    * Protect top of stack from heap, but this will not protect the heap from
    * stack overruns.
diff --git a/ux00_zsbl.lds b/ux00_zsbl.lds
index a14f4e6..0ea8880 100644
--- a/ux00_zsbl.lds
+++ b/ux00_zsbl.lds
@@ -19,8 +19,8 @@ PHDRS
 
 SECTIONS
 {
-  PROVIDE(_ram = ORIGIN(ccache_sideband));
-  PROVIDE(_ram_end = _ram + LENGTH(ccache_sideband));
+  PROVIDE(_ram = ORIGIN(dtim_mem));
+  PROVIDE(_ram_end = _ram + LENGTH(dtim_mem));
 
   
 
@@ -49,36 +49,36 @@ SECTIONS
     *(.srodata.*)
   } >maskrom_mem  :rodata
 
-  .data ALIGN((ORIGIN(ccache_sideband) + 0x100000), 64) : AT(ALIGN((LOADADDR(.srodata) + SIZEOF(.srodata)), 64)) ALIGN_WITH_INPUT {
+  .data ALIGN((ORIGIN(dtim_mem) + 0x3000), 64) : AT(ALIGN((LOADADDR(.srodata) + SIZEOF(.srodata)), 64)) ALIGN_WITH_INPUT {
     *(.data .data.* .gnu.linkonce.d.*)
     *(.tohost) /* TODO: Support sections that aren't explicitly listed in this linker script */
-  } >ccache_sideband  :data
+  } >dtim_mem  :data
 
   .sdata ALIGN((ADDR(.data) + SIZEOF(.data)), 64) : AT(ALIGN((LOADADDR(.data) + SIZEOF(.data)), 64)) ALIGN_WITH_INPUT {
     *(.sdata .sdata.* .gnu.linkonce.s.*)
-  } >ccache_sideband  :data
+  } >dtim_mem  :data
 
   PROVIDE(_data = ADDR(.data));
   PROVIDE(_data_lma = LOADADDR(.data));
   PROVIDE(_edata = .);
 
-  .bss ALIGN((ADDR(.sdata) + SIZEOF(.sdata)), 64) : AT(ALIGN((ORIGIN(ccache_sideband) + 0x100000), 64)) ALIGN(8) {
+  .bss ALIGN((ADDR(.sdata) + SIZEOF(.sdata)), 64) : AT(ALIGN((ORIGIN(dtim_mem) + 0x3000), 64)) ALIGN(8) {
     PROVIDE(_fbss = .);
     PROVIDE(__global_pointer$ = . + 0x7C0);
     *(.sbss .sbss.* .gnu.linkonce.sb.*)
     *(.bss .bss.* .gnu.linkonce.b.*)
     . = ALIGN(8);
     PROVIDE(_ebss = .);
-  } >ccache_sideband  :bss
+  } >dtim_mem  :bss
 
   PROVIDE(_end = .);
 
   /*
-   * heap_stack_region_usable_end: (ORIGIN(ccache_sideband) + LENGTH(ccache_sideband))
+   * heap_stack_region_usable_end: (ORIGIN(dtim_mem) + LENGTH(dtim_mem))
    * heap_stack_min_size: 4096
    * heap_stack_max_size: 1048576
    */
-  PROVIDE(_sp = ALIGN(MIN((ORIGIN(ccache_sideband) + LENGTH(ccache_sideband)), _ebss + 1048576) - 7, 8));
+  PROVIDE(_sp = ALIGN(MIN((ORIGIN(dtim_mem) + LENGTH(dtim_mem)), _ebss + 1048576) - 7, 8));
   /*
    * Protect top of stack from heap, but this will not protect the heap from
    * stack overruns.
diff --git a/ux00boot/ux00boot.c b/ux00boot/ux00boot.c
index 43d2aa9..328e100 100644
--- a/ux00boot/ux00boot.c
+++ b/ux00boot/ux00boot.c
@@ -522,7 +522,7 @@ void ux00boot_fail(long code, int trap)
  */
 void ux00boot_load_gpt_partition(void* dst, const gpt_guid* partition_type_guid, unsigned int peripheral_input_khz)
 {
-  uint32_t mode_select = *((volatile uint32_t*) MODESELECT_MEM_ADDR);
+  uint32_t mode_select = 11;
 
   spi_ctrl* spictrl = NULL;
   void* spimem = NULL;
diff --git a/zsbl/main.c b/zsbl/main.c
index aea2a1f..8b0244f 100644
--- a/zsbl/main.c
+++ b/zsbl/main.c
@@ -15,7 +15,7 @@ static Barrier barrier;
 extern const gpt_guid gpt_guid_sifive_fsbl;
 
 
-#define CORE_CLK_KHZ 33000
+#define CORE_CLK_KHZ 50000
 
 
 void handle_trap(void)
@@ -39,13 +39,13 @@ int main()
 {
   if (read_csr(mhartid) == NONSMP_HART) {
     unsigned int peripheral_input_khz;
-    if (UX00PRCI_REG(UX00PRCI_CLKMUXSTATUSREG) & CLKMUX_STATUS_TLCLKSEL) {
+    if (1) {
       peripheral_input_khz = CORE_CLK_KHZ; // perpheral_clk = tlclk
     } else {
       peripheral_input_khz = (CORE_CLK_KHZ / 2);
     }
     init_uart(peripheral_input_khz);
-    ux00boot_load_gpt_partition((void*) CCACHE_SIDEBAND_ADDR, &gpt_guid_sifive_fsbl, peripheral_input_khz);
+    ux00boot_load_gpt_partition((void*) DTIM_MEM_ADDR, &gpt_guid_sifive_fsbl, peripheral_input_khz);
   }
 
   Barrier_Wait(&barrier, NUM_CORES);
diff --git a/zsbl/start.S b/zsbl/start.S
index e0f85b2..adcd978 100644
--- a/zsbl/start.S
+++ b/zsbl/start.S
@@ -75,7 +75,7 @@ _start:
 
   call main
 
-  li t0, CCACHE_SIDEBAND_ADDR
+  li t0, DTIM_MEM_ADDR
   csrr a0, mhartid
   la a1, _dtb
   jr t0
